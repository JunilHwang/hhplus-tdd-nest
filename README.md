## κ³Όμ  μν–‰ μ μ°¨

### `STEP01 - κΈ°λ¥ μ¶”κ°€ λ° ν…μ¤νΈ κµ¬ν„`

- ν¬μΈνΈ μ¶©μ „, μ‚¬μ©μ— λ€ν• μ •μ±… μ¶”κ°€ (μ”κ³  λ¶€μ΅±, μµλ€ μ”κ³  λ“±)
- 4κ°€μ§€ κΈ°λ³Έ κΈ°λ¥ (ν¬μΈνΈ μ΅°ν, ν¬μΈνΈ μ¶©μ „/μ‚¬μ© λ‚΄μ—­ μ΅°ν, μ¶©μ „, μ‚¬μ©)μ— λ€ν• κµ¬ν„
- 4κ°€μ§€ κΈ°λ³Έ κΈ°λ¥μ— λ€ν• ν…μ¤νΈ μ‘μ„±
- λ‹¨, μ΄λ• `/database` ν¨ν‚¤μ§€μ κµ¬ν„μ²΄λ” μμ •ν•μ§€ μ•κ³ , μ΄λ¥Ό ν™μ©ν•΄ κΈ°λ¥μ„ κµ¬ν„ν•¨

### `STEP02- λ™μ‹μ„± ν•™μµ λ° κµ¬ν„`

- λ™μΌν• μ‚¬μ©μμ— λ€ν• λ™μ‹ μ”μ²­μ— λ€ν• ν…μ¤νΈλ¥Ό λ¨Όμ € μ‘μ„±ν•¨
- μ΄ν›„ ν•΄λ‹Ή ν…μ¤νΈκ°€ μ •μƒμ μΌλ΅ μ²λ¦¬λ  μ μλ„λ΅ κ°μ„ ν•¨
- **μ„ νƒν• μ–Έμ–΄μ— λ€ν•** λ™μ‹μ„± μ μ–΄ λ°©μ‹ λ° κ° μ μ©μ μ¥/λ‹¨μ μ„ κΈ°μ ν• λ³΄κ³ μ„ μ‘μ„±


## κ³Όμ  μ”κµ¬μ‚¬ν•­

`point` ν¨ν‚¤μ§€μ TODO μ™€ ν…μ¤νΈμ½”λ“λ¥Ό μ‘μ„±ν•΄μ£Όμ„Έμ”.

### API μ”κµ¬μ‚¬ν•­

- [X] PATCH  `/point/{id}/charge` : ν¬μΈνΈλ¥Ό μ¶©μ „ν•λ‹¤.
- [X] PATCH `/point/{id}/use` : ν¬μΈνΈλ¥Ό μ‚¬μ©ν•λ‹¤.
- [X] GET `/point/{id}` : ν¬μΈνΈλ¥Ό μ΅°νν•λ‹¤.

### κΈ°λ¥ μ”κµ¬μ‚¬ν•­

- [X] GET `/point/{id}/histories` : ν¬μΈνΈ λ‚΄μ—­μ„ μ΅°νν•λ‹¤.
- [X] μ”κ³ κ°€ λ¶€μ΅±ν•  κ²½μ°, ν¬μΈνΈ μ‚¬μ©μ€ μ‹¤ν¨ν•μ—¬μ•Ό ν•©λ‹λ‹¤.

### π€Level-UP

- [ ] κ°™μ€ μ‚¬μ©μκ°€ λ™μ‹μ— μ¶©μ „ν•  κ²½μ°, ν•΄λ‹Ή μ”μ²­ λ¨λ‘ μ •μƒμ μΌλ΅ λ°μλμ–΄μ•Ό ν•©λ‹λ‹¤.

## λ™μ‹μ„± μ μ–΄ λ°©μ‹ λΉ„κµ

### (1) Queue κΈ°λ° λ°©μ‹

κ°λ…: μ‚¬μ©μλ³„ μ”μ²­ νλ¥Ό μƒμ„±ν•μ—¬ μμ°¨ μ²λ¦¬

```typescript
// μ‚¬μ©μλ³„ ν κ΄€λ¦¬
private userQueues = new Map<number, Promise<any>>();

async processWithQueue(userId: number, operation: () => Promise<any>) {
  const currentQueue = this.userQueues.get(userId) || Promise.resolve();
  const newQueue = currentQueue.then(() => operation());
  this.userQueues.set(userId, newQueue);
  return newQueue;
}
```

μ¥μ 
- κµ¬ν„μ΄ κ°„λ‹¨ν•κ³  μ§κ΄€μ 
- λ°μ΄ν„° μΌκ΄€μ„± 100% λ³΄μ¥
- μμ„ λ³΄μ¥μΌλ΅ μμΈ΅ κ°€λ¥ν• κ²°κ³Ό
- λ©”λ¨λ¦¬ κΈ°λ° DBμ— μ ν•©

λ‹¨μ 
- μ²λ¦¬ μ‹κ°„μ΄ κΈΈμ–΄μ§ μ μμ (μμ°¨ μ²λ¦¬)
- μ²« λ²μ§Έ μ”μ²­μ΄ μ‹¤ν¨ν•λ©΄ ν›„μ† μ”μ²­ μ§€μ—°
- λ©”λ¨λ¦¬ μ‚¬μ©λ‰ μ¦κ°€ (ν κ΄€λ¦¬)

### (2) Lock κΈ°λ° λ°©μ‹

μ‚¬μ©μλ³„ λ½μ„ μ‚¬μ©ν•μ—¬ λ™μ‹ μ ‘κ·Ό μ μ–΄

```typescript
// μ‚¬μ©μλ³„ λ½ κ΄€λ¦¬
private userLocks = new Map<number, boolean>();

async processWithLock(userId: number, operation: () => Promise<any>) {
  while (this.userLocks.get(userId)) {
    await new Promise(queueMicrotask(resolve));
  }
  this.userLocks.set(userId, true);
  try {
    return await operation();
  } finally {
    this.userLocks.set(userId, false);
  }
}
```

μ¥μ 
- λΉ λ¥Έ μ²λ¦¬ μ†λ„
- λ¦¬μ†μ¤ μ‚¬μ©λ‰ μµμ†ν™”
- μ‹¤ν¨ν• μ”μ²­μ΄ λ‹¤λ¥Έ μ”μ²­μ— μν–¥ μ—†μ

λ‹¨μ 
- κµ¬ν„ λ³µμ΅λ„ μ¦κ°€
- λ°λ“λ½ μ„ν—μ„±
- λ½ κ΄€λ¦¬ μ¤λ²„ν—¤λ“

### 3. Atomic μ—°μ‚° λ°©μ‹

μ›μμ  μ—°μ‚°μ„ ν†µν• λ™μ‹μ„± μ μ–΄

```typescript
async atomicUpdate(userId: number, updateFn: (current: number) => number) {
  const current = await this.getUserPoint(userId);
  const newValue = updateFn(current.point);
  return await this.updatePoint(userId, newValue);
}
```

μ¥μ :
- κ°€μ¥ λΉ λ¥Έ μ²λ¦¬ μ†λ„
- κµ¬ν„μ΄ μƒλ€μ μΌλ΅ κ°„λ‹¨
- μ‹μ¤ν… λ¦¬μ†μ¤ μµμ† μ‚¬μ©

λ‹¨μ :
- λ³µμ΅ν• λΉ„μ¦λ‹μ¤ λ΅μ§μ— μ μ© μ–΄λ ¤μ›€
- ν„μ¬ κµ¬μ΅°μ—μ„λ” μ ν•μ  ν™μ©
- λ¶€λ¶„ μ‹¤ν¨ μ‹ λ΅¤λ°± λ³µμ΅

## μμ‚¬κ²°μ •μ„ ν•΄λ³΄μ

ν„μ¬ ν”„λ΅μ νΈ νΉμ„±μ„ κ³ λ ¤ν•  λ• Queue κΈ°λ° λ°©μ‹μ΄ μ ν•©ν•μ§€ μ•μ„κΉ?
λ‹¨μν•κ³ , ν…μ¤νΈ μ‘μ„±κ³Ό κ²€μ¦μ΄ μ©μ΄ν•κ³ , λ™μ‹μ„± μ μ–΄ κ°λ… μ΄ν•΄μ— μ ν•©ν•κ³ , ν–¥ν›„ μ‹¤μ  DB ν™κ²½μΌλ΅ ν™•μ¥ μ‹ λ‹¤λ¥Έ λ°©μ‹μΌλ΅ λ³€κ²½ κ°€λ¥ν•λ‹¤.
